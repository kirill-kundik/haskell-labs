> import Data.List
> import qualified Data.Map as Map

Строгі ліві згортки!

Іноді використання функції foldl може приводити до помилок переповнення стеку, які трапляються, коли програма використовує забагато місця в одному спеціальному розділі пам’яті (сегменті стеку). Наприклад: 

> fst = foldl (+) 0 (replicate 100 1) 

Буде виведено -> 100

> snd = foldl (+) 0 (replicate 1000000 1) 

Буде виведено -> *** Exception: stack overflow

Насправді, проблема в тому, що містер Хаскель настільки лінив, що відкладає усі обрахунки настільки, наскільки це можливо.
Тому на кожному кроці виконання Хаскель нічого не обраховує, замість цього він все відкладає.
Йому, правда, доводиться зберігати старий відкладений обрахунок в пам’яті, тому що новому (обрахунку) може знадобитися результат старого.
Тому, поки згортка пробігається по списку, в пам’яті створюється купа відкладених обрахунків, кожне з яких займає певний об’єм пам’яті.

Як це працює "під капотом":
foldl (+) 0 [1,2,3] =
foldl (+) (0 + 1) [2,3] = 
foldl (+) ((0 + 1) + 2) [3] = 
foldl (+) (((0 + 1) + 2) + 3) [] = 
((0 + 1) + 2) + 3 = 
(1+2) + 3 = 
3 + 3 = 
6 

Як би нам хотілося:
foldl' (+) 0 [1,2,3] = 
foldl' (+) 1 [2,3] = 
foldl' (+) 3 [3] = 
foldl (+) 6 [] = 
6 

> third = foldl' (+) 0 (replicate 1000000 1) 

Буде виведено -> 1000000

Строга версія також є для foldl1 = foldl1’

Функція пошуку в списках:

find :: (a -> Bool) -> [a] -> Maybe a

> fourth = find (>4) [3,4,5,6,7] 

Буде виведено: Just 5 

> fifth = find odd [2,4,6,8,9]

Буде виведено: Just 9 

> sixth = find (=='x') "mech-kladenets" 

Буде виведено: Nothing

---------------------------------------------
Відображення ключів на значенні

Один з способів це зробити - асоциативні списки.

> phoneBook = [("olya","555–29-38"), ("zhenya","452–29-28"), ("katya","493–29-28"), ("masha","205–29-28"), ("nadya","939–82-82"), ("yulya","853–24-92")]

Пошук значення за ключем!

> findKey key [] = Nothing 
> findKey key ((k,v):xs) | key == k = Just v
>                                    | otherwise = findKey key xs

Але найкраще це зробити за допомогою згортки!

findKey key = foldr (\(k,v) acc –>{-- if key == k then Just v else acc) Nothing --}

Для запуску необхідно прибрати коментар, бо у мене виникли помилки з конструкцією анонімної функціі.

Також за допомогою Data.Map (необхідно імпортувати за допомогою qualified, тому що деяки методи вступають в конфлікт з модулем Prelude та Data.List) можна створити відображення на основі списка, воно використовує в основі дерева, тому набагато краще організована пам'ять, шо використовується та пошук і вставка.

> list1 = Map.fromList [(3, "tufli"),(4,"derevya"), (9,"pcholy")] 

Буде виведено: fromList [(3, "tufli"),(4,"derevya"),(9,"pcholy")] 

> list2 = Map.fromList [("erik","forman"), ("robert","chaise"),("chris", "taub")] 

Буде виведено: fromList [("chris","taub"),("robert","chaise"), ("erik","forman")] 

> list3 = Map.fromList [("MS",1),("MS",2),("MS",3)] 

Буде виведено: fromList [("MS",3)]

> phoneBook2 = Map.fromList $ [("olya","555–29-38"), ("zhenya","452–29-28"), ("katya","493–29-28"), ("masha","205–29-28"), ("nadya","939–82-82"), ("yulya","853–24-92")] 

Наш phoneBook, але вже обгорнутий за допомогою модуля Map та функції fromList
І тепер замість фукнції find ми можемо використовувати з модуля Map функцію lookup, яка працює за таким самим принципом

> phoneBookRes1 = Map.lookup "olya" phoneBook2 

Буде виведено: Just "555-29-38" 

> phoneBookRes2 = Map.lookup "nadya" phoneBook2

Буде виведено: Just "939-82-82" 

> phoneBookRes3 = Map.lookup "tanya" phoneBook2 

Буде виведено: Nothing 

Тепер ми хочемо додати якийсь ключ та значення для вже існючого відображення.
Новий ключ буде збережено, але якщо ключ вже існував в відображенні, то нове значення затре старе.

> newBook = Map.insert "таня" "341-90-21" phoneBook2 
> phoneBookRes4 = Map.lookup "таня" newBook 

Just "341-90-21" 

> sizePhoneBook = Map.size phoneBook2

Буде виведено: 6 

> sizeNewBook = Map.size newBook

Буде виведено: 7

У нас виникає проблема, що якщо у ключа декілька значень, то останнє (нове) затирає усі попередні (старі) значення, тобто було б круто, якщо ми могли зберігати декілька значень для одного ключа.

> phoneBook3 = [("olya","555–29-38"), ("olya","342–24-92"), ("zhenya","452–29-28"), ("katya","493–29-28"), ("katya","943–29-29"), ("katya","827–91-62"), ("masha","205–29-28"), ("nadya","939–82-82"), ("yulya","853–24-92"), ("yulya","555–21-11")] 

Ми можемо цього досягнути за допомогою функції Map.fromListWith, за допомогою якої можна вирішувати конфлікти, коли до одного ключа додається більше ніж одне значення. Наприклад, функція конатенації списків:

> phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -> (k, [v])) xs
> phoneBookRes5 = Map.lookup "katya" $ phoneBookToMap phoneBook3 

Буде виведено: Just ["827–91-62","943–29-29","493–29-28"]

Або ж функція, що бере максимальне значення з двох чисел. Тобто для ключа зі списку значень візметься тільки найбільше:

> maxMap = Map.fromListWith max [(2,3),(2,100),(3,29), (3,11),(4,22),(4,15)] 

Буде виведено: fromList [(2,100),(3,29),(4,22)]

Це для суми двох чисел:

> sumMap = Map.fromListWith (+) [(2,3),(2,100),(3,29), (3,11),(4,22),(4,15)]

Буде виведено: fromList [(2,103),(3,40),(4,37)]

Дякую за увагу!